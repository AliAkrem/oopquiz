final examples = [
  {
    "quiz_id": 40,
    "quiz_tag": "Graphs",
    "question_content":
        '''## Graphs\n\nwe want to write a program to manage integer graphs (each vertex is an integer value).\nWe want to be able to represent graphs of any type (directed or undirected, simple or not, etc.).\nbut every graph must offer methods for :\n\n- add an integer as a vertex\n- remove a vertex from the graph\n- add an edge between two given vertices\n- delete an edge between two given vertices\n- find out whether an edge exists between two given vertices\n\nNB: The way these methods are implemented may depend on the type of graph. For example,\nexample, adding an edge between two vertices of a simple graph is only possible if the two\nvertices are not already linked by an edge, whereas you can always add an edge in a multi\ngraph.\n\na. Propose some object code to represent the vertices and edges of an integer graph.\n\nb. Propose object code to represent integer graphs in general.\n\nc. Propose object code to represent undirected graphs. This code should make it possible to add or delete a vertex and find out whether an edge exists between two given vertices.\n\nd. Propose object code to represent simple undirected graphs, i.\ne. undirected graphs\nundirected graphs where there is at most one edge between two vertices. This code must make it possible to\nadd and remove an edge between two given vertices.\n\n## Solution\n\n```java\npublic class Node{\nprivate int value;\npublic Node(int i){\nthis.value = i;\n}\n}\npublic class Edge{\nprivate Node from, to;\npublic Edge(Node from, Node to){\nthis.from = from;\nthis.to = to;\n}\npublic boolean links(Node n){\nreturn this.from.equals(n) || this.to.equals(n);\n}\npublic boolean fromTo(Node from, Node to){\nreturn this.from.equals(from) && this.to.equals(to);\n}\n}\npublic interface Graph{\npublic boolean addNode(int i);\npublic boolean addEdge(Node n1, Node n2);\npublic boolean removeNode(Node n);\npublic boolean removeEdge(Node n1, Node n2);\n// return null if there is no edge between from and to\npublic Edge getEdge(Node from, Node to);\n}\nimport java.util.ArrayList;\npublic abstract class UndirectedGraph implements Graph{\nprotected ArrayList<Node> nodes;\nprotected ArrayList<Edge> edges;\npublic UndirectedGraph(){\nthis.nodes = new ArrayList<Node>();\nthis.edges = new ArrayList<Edge>();\n}\npublic boolean addNode(int i){\nreturn this.nodes.add(new Node(i));}\npublic boolean removeNode(Node n){\nboolean b = this.nodes.remove(n);\nif(b){\nArrayList<Edge> newEdges = new ArrayList<Edge>();\nfor(Edge e:this.edges){\nif(!e.links(n)) newEdges.add(e);\n}\nthis.edges = newEdges;\n}\nreturn b;\n}\npublic Edge getEdge(Node n1, Node n2){\nfor(Edge e:this.edges){\nif(e.fromTo(n1,n2) || e.fromTo(n2,n1)) return e;\n}\nreturn null;\n}\n}\npublic class SimpleUndirectedGraph extends UndirectedGraph{\npublic SimpleUndirectedGraph(){\nsuper();\n}\npublic boolean addEdge(Node n1, Node n2){\nif(this.getEdge(n1,n2)==null)\nreturn this.edges.add(new Edge(n1,n2));\nelse return false;\n}\npublic boolean removeEdge(Node n1, Node n2){\nEdge ed = this.getEdge(n1,n2);\nif(ed!=null) return this.edges.remove(ed);\nelse return false;\n}\n}\n```''',
    "answers": [
      // correct answer
      "no answer"
    ],
    "details": "no details",
    "correct_answer": 0,
  },
  {
    "quiz_id": 41,
    "quiz_tag": "Russian dolls",
    "question_content":
        '''## Russian dolls\n\nwe want to write a program simulating Russian dolls of various sizes. Each\ndoll has a given size, can open or close, can contain another doll and be contained in another doll.\nin another doll.\nWrite a Russian Doll class containing the following methods:\n\n- a constructor\n- void open(): opens the doll if it is not already open and if it is not inside another doll.\n  inside another doll\n- void close(): closes the doll if it is not already closed and if it is not inside\n  inside another doll\n- void placeIn(Russian doll p): places the current doll in doll p, if possible.\n  possible. The current doll must be closed and not already inside another doll,\n  p must be open and contain no doll, and p must be larger than the current doll.\n  than the current doll.\n- void getOutOf(RussianDoll p): takes the current doll out of doll p if it is in p\n  and p is open.\n\n## Solution\n\n```java\nclass RussianDoll {\nint size;\nboolean open;\nRussianDoll in, contains;\nRussianDoll(int size) {\nthis.size = size;\nthis.opened = false;\n}\nvoid open() {\nif(!this.opened && this.dans==null) this.opened = true;\n}\nvoid close() {\nif(this.open && this.in == null) this.open = false;\n}\nvoid placeIn(RussianDoll p) {\nif(!this.open && this.in == null && p.open && p.contains == null && p.size> this.size)\n{\nthis.in = p;\np.contains = this;\n}\n}\nvoid getOutOf(RussianDoll p) {\nif(p.open && p.contains == this) {\nthis.in = null;\np.contains = null;\n}\n}\n}\n```''',
    "answers": ["no answer"],
    "details": "no details",
    "correct_answer": 0
  },
  {
    "quiz_id": 42,
    "quiz_tag": "Watches",
    "question_content":
        '''## Watches\n\nwe want to create a program representing watches and the people who wear them.\nA watch gives the hours and minutes. A watch can be initialized either from a given hour/minute pair, or by using the time displayed by another watch. It must be possible to\nby adding one minute (note that minutes are limited to 60 and hours to 24).\n\na. Write a class representing the watches described above and a main method\nthat creates a watch displaying 13:45 and another watch that is a clone of the first.\n\nA person has a name and can wear a watch. You can make a person wear\ngiven to a person, if they don't already have one. You can also take away a watch if the person\nhas one. One person can ask another for the time, and the latter will tell him the time in the form of a string\nof characters, by consulting his watch if he has one (otherwise he can return an empty string).\n\nb. Write a class that represents people as described above.\n\nc. We want each watch to be worn by only one person. Suggest\nadditions/modifications to the two preceding classes to guarantee this.\n\n## Solution\n\n```java\nclass Watch{\nint hour, min;\nPerson p; // for 2.3\nWatch(int h, int m){\nthis.hour = h;\nthis.min = m;\n}\nWatch(Watch m){\nthis.hour = m.hour;\nthis.min = m.min;\n}\nvoid advance(){\nif(this.min==59){\nif(this.hour == 23) this.hour = 0;\nelse this.hour = this.hour++;\nthis.min = 0;\n}\nelse this.min++;\n}\npublic static void main(String[] toto){\nShow m = new Show(13,45);\nShow n = new Show(m);\n}\n}\nclass Person{\nString name;\nShow m;\nPerson(String name){\nthis.name = name;\nthis.m = null;\n}\nboolean watchHolder(Watch m){\nif(m.p!=null && this.m==null){\nthis.m = m;\nm.p = this; // for 2.3\nreturn true;\n}\nelse return false;\n}\nWatch removeWatch(){\nWatch m = this.m;\nthis.m = null;\nif(m!=null) m.p=null; // for 2.3\nreturn m;\n}\nString givesTime(){\nif(this.m != null) return this.m.hour+"h "+this.m.min;\nelse return "";\n}\n}\n```''',
    "answers": ["no answer"],
    "details": "no details",
    "correct_answer": 0
  },
  {
    "quiz_id": 43,
    "quiz_tag": "Dishes",
    "question_content":
        '''## Dishes\n\nwe want to develop a recipe management program that will be installed on\nappliances to enable them to cook independently. A\nprogrammer has already written the Ingredient class given below:\n\n```java\nclass Ingredient{\nString food_name, state;\nint quantity;\nString unite;\nIngredient(String n, String e, int q, String unite){\nthis.food_name = n;\nthis.state = e;\nthis.quantity = q;\nthis.unite = unite;\n}\n}\n```\n\nNB: the state of an ingredient may be cooked, whole, raw, cut, or a combination of these states (e.g. cooked and whole).\nThe unit can be a weight unit (gram, kg, etc.), a volume unit (liter, ml, cl)\nor simply a cardinality.\n\na. Write a Dish class that represents dishes, each dish having a name and a list of ingredients. It must be possible to create a dish with\nits name. We also need accessors for\nthe dish name and ingredients, and be able to add an ingredient to a dish. Also write a\nmethod that creates a dish called sauerkraut with the following ingredients: 500g cooked sauerkraut\n150g whole cooked bacon and 2 whole cooked sausages.\n\nb. We want to be able to compare the dishes and therefore their ingredients. Add an equals method\nmethod in the Ingredient class, which returns true if two ingredients have the same food name and the same\nstate (not necessarily the same quantity). Add an equals method to the Dish class, which returns true\nif two dishes contain the same ingredients, in the sense given above.\n\nc. We want to distinguish between ingredients that can be cooked and those that can be cut.\nAn ingredient that can be cooked must have a cook() method that puts it in the "cooked" state, and a cook temperature.\ncooking temperature. An ingredient that can be cut must have a cut() method which\ninto the "cut" state. Suggest some object code to represent these types of ingredients.\n\n## Solution\n\n```java\nclass Plat{\nString name;\nArrayList<Ingredient> ingredients;\nDish(String n){\nthis.name = n;\nthis.ingredients = new ArrayList<Ingredient>();\n}\nString getName(){\nreturn this.name;\n}\nArrayList<Ingredient> getIngredients(){\nreturn this.ingredients;\n}\nvoid addIngredient(Ingredient i){\nthis.ingredients.add(i);\n}\n// for b.\nprotected boolean equals(Object o){\nif(o instanceof Plat){\nfor(Ingredient i:this.ingredients){\nif(!((Dish) o).ingredients.contains(i)) return false;\n}\nreturn this.ingredients.size() ==\n((Dish) o).ingredients.size();\n}\nelse return false;\n}\npublic static void main(String[] toto){\nDish p = new Dish("Sauerkraut");\np.addIngredient(new Ingredient("sauerkraut", "cooked",500, "g"));\np.addIngredient(new Ingredient("lard", "cuit_entier",150, "g"));\np.addIngredient(new Ingredient("saucisse", "cuit_entiere",2,\n"cardinalite"));\n}\n}\n// for b.\nclass Ingredient{\n\nprotected boolean equals(Object o){\nreturn (o instanceof Ingredient) &&\nthis.food_name.equals(((Ingredient) o).food_name) &&\nthis.state.equals(((Ingredient) o).state);\n}\n}\nclass IngredientToCook extends Ingredient{\nint temperature;\nIngredientToCook(String n, String e, int q, String unite, int t){\nsuper(n,e,q,unite);\nthis.temperature = t;\n}\nvoid cooked(){\nthis.state = "cooked";\n}\n}\nclass IngredientToCut extends Ingredient{\nIngredientToCut(String n, String e, int q, String unite){\nsuper(n,e,q,unite);\n}\nvoid cut(){\nthis.state = "cutting";\n}\n}\n```\n''',
    "answers": ["no answer"],
    "details": "no details",
    "correct_answer": 0
  },
];
